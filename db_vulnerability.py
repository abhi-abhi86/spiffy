#⚠️ DO NOT RUN THIS UNDER ANY CIRCUMSTANCES!

#I am not responsible for any damage or misuse.

#This is for educational purposes only.

# and mfs this is not you 

import sqlite3
import logging
import hashlib
import hmac
import os
import sys
import time
import re
import getpass
import random
import string
import urllib.request
import urllib.parse
import urllib.error
import ssl
import socket
import asyncio
import json
from contextlib import contextmanager
from datetime import datetime, timedelta
from typing import Optional, Tuple, List, Dict, Any

# --- CONFIGURATION ---
DB_FILE = "spiffy_vault.db"
LOG_FILE = "spiffy_audit.log"
REPORT_FILE = "spiffy_report.json"
MAX_LOGIN_ATTEMPTS = 5
LOCKOUT_DURATION_MINUTES = 15

# --- ANSI COLORS (EMERALD CYBER THEME) ---
C_GREEN = "\033[38;5;46m"    
C_D_GREEN = "\033[38;5;22m"  
C_CYAN = "\033[38;5;81m"
C_YELLOW = "\033[38;5;220m"
C_RED = "\033[38;5;196m"
C_MAGENTA = "\033[38;5;171m"
C_WHITE = "\033[38;5;255m"
C_GRAY = "\033[38;5;240m"
C_BOLD = "\033[1m"
C_END = "\033[0m"
C_CLEAR = "\033[H\033[J"

ssl_context = ssl.create_default_context()
ssl_context.check_hostname = False
ssl_context.verify_mode = ssl.CERT_NONE

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s [%(levelname)s] %(name)s: %(message)s',
    handlers=[logging.FileHandler(LOG_FILE)]
)
logger = logging.getLogger("SpiffyKernel")

class DatabaseManager:
    def __init__(self, db_path: str = DB_FILE):
        self.db_path = db_path
        self._initialize_infrastructure()

    @contextmanager
    def get_connection(self):
        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row
        try:
            yield conn
        finally:
            conn.close()

    def _initialize_infrastructure(self):
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS users (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    username TEXT UNIQUE NOT NULL,
                    password_hash BLOB NOT NULL,
                    salt BLOB NOT NULL,
                    failed_attempts INTEGER DEFAULT 0,
                    lockout_until TIMESTAMP
                )
            ''')
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS secrets (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER NOT NULL,
                    title TEXT NOT NULL,
                    website TEXT,
                    username_ref TEXT,
                    secret_value TEXT NOT NULL,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users (id)
                )
            ''')
            cursor.execute('CREATE INDEX IF NOT EXISTS idx_user_id ON secrets(user_id)')
            conn.commit()

    def _hash_password(self, password: str, salt: bytes = None) -> Tuple[bytes, bytes]:
        if salt is None:
            salt = os.urandom(16)
        pw_hash = hashlib.scrypt(password.encode(), salt=salt, n=16384, r=8, p=1)
        return pw_hash, salt

    def register_user(self, username: str, password: str) -> Tuple[bool, str]:
        pw_hash, salt = self._hash_password(password)
        with self.get_connection() as conn:
            try:
                conn.execute(
                    "INSERT INTO users (username, password_hash, salt) VALUES (?, ?, ?)",
                    (username, pw_hash, salt)
                )
                conn.commit()
                return True, "SYSTEM: Identity Provisioned. Welcome to the Spiffy Grid."
            except sqlite3.IntegrityError:
                return False, "CRITICAL: Identity Conflict. Subject already indexed."

    def login(self, username: str, password: str) -> Tuple[Optional[int], str]:
        now = datetime.now()
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM users WHERE username = ?", (username,))
            user = cursor.fetchone()
            if not user: return None, "SECURITY: Identity Verification Failed."

            if user['lockout_until']:
                lockout_time = datetime.fromisoformat(user['lockout_until'])
                if now < lockout_time:
                    wait_time = (lockout_time - now).seconds // 60 + 1
                    return None, f"LOCKOUT: Protocol active. Retry in {wait_time}m."

            provided_hash, _ = self._hash_password(password, user['salt'])
            if hmac.compare_digest(user['password_hash'], provided_hash):
                conn.execute("UPDATE users SET failed_attempts = 0, lockout_until = NULL WHERE username = ?", (username,))
                conn.commit()
                return user['id'], "AUTHORIZED"
            else:
                new_fails = user['failed_attempts'] + 1
                lockout_ts = (now + timedelta(minutes=LOCKOUT_DURATION_MINUTES)).isoformat() if new_fails >= MAX_LOGIN_ATTEMPTS else None
                conn.execute("UPDATE users SET failed_attempts = ?, lockout_until = ? WHERE username = ?", (new_fails, lockout_ts, username))
                conn.commit()
                return None, f"ALERT: Invalid credentials ({new_fails}/{MAX_LOGIN_ATTEMPTS})."

    def add_secret(self, user_id: int, title: str, website: str, user_ref: str, value: str):
        with self.get_connection() as conn:
            conn.execute(
                "INSERT INTO secrets (user_id, title, website, username_ref, secret_value) VALUES (?, ?, ?, ?, ?)",
                (user_id, title, website, user_ref, value)
            )
            conn.commit()

    def get_secrets(self, user_id: int, search: str = "") -> List[sqlite3.Row]:
        with self.get_connection() as conn:
            cursor = conn.cursor()
            if search:
                cursor.execute(
                    "SELECT * FROM secrets WHERE user_id = ? AND (title LIKE ? OR website LIKE ?)",
                    (user_id, f"%{search}%", f"%{search}%")
                )
            else:
                cursor.execute("SELECT * FROM secrets WHERE user_id = ?", (user_id,))
            return cursor.fetchall()

class SpiffyTunnel:
    def __init__(self):
        self.active = False
        self.virtual_ip = None
        self.expiry_time = None

    def establish(self, duration_mins: int = 20):
        self.virtual_ip = f"{random.randint(10, 254)}.{random.randint(10, 254)}.{random.randint(10, 254)}.{random.randint(10, 254)}"
        self.expiry_time = datetime.now() + timedelta(minutes=duration_mins)
        self.active = True
        return self.virtual_ip

    def is_active(self):
        if self.active and datetime.now() > self.expiry_time:
            self.active = False
            self.virtual_ip = None
            return False
        return self.active

    def get_remaining_time(self):
        if not self.active: return "00:00"
        rem = self.expiry_time - datetime.now()
        secs = int(rem.total_seconds())
        if secs < 0: return "00:00"
        return f"{secs // 60:02d}:{secs % 60:02d}"

class SpiffyAuditor:
    SECURITY_HEADERS = {
        "Content-Security-Policy": "XSS Mitigation",
        "Strict-Transport-Security": "HSTS Protocol",
        "X-Frame-Options": "Clickjacking Shield",
        "X-Content-Type-Options": "MIME Guard",
        "Access-Control-Allow-Origin": "CORS Policy"
    }

    @staticmethod
    async def probe_port(host: str, port: int) -> Optional[int]:
        try:
            _, writer = await asyncio.wait_for(asyncio.open_connection(host, port), timeout=0.8)
            writer.close()
            await writer.wait_closed()
            return port
        except:
            return None

    @staticmethod
    def audit_url(url: str) -> Dict[str, Any]:
        if not url.startswith(('http://', 'https://')): url = 'http://' + url
        report = {"url": url, "status": "Error", "headers": {}, "risks": [], "server": "Hidden"}
        try:
            req = urllib.request.Request(url, headers={'User-Agent': 'SpiffySentinel/13.0'})
            with urllib.request.urlopen(req, timeout=8, context=ssl_context) as response:
                report["status"] = response.getcode()
                headers = response.info()
                report["server"] = headers.get("Server", "Unknown")
                for h, desc in SpiffyAuditor.SECURITY_HEADERS.items():
                    report["headers"][h] = "ACTIVE" if h in headers else "MISSING"
                
                content = response.read().decode('utf-8', errors='ignore').lower()
                if 'wp-content' in content: report['risks'].append("WordPress Ecosystem Detected")
                if 'api_key' in content or 'secret_key' in content: report['risks'].append("Potential API Leakage in Source")
        except Exception as e:
            report["error"] = str(e)
        return report

class SpiffyTracker:
    @staticmethod
    def get_local_ip() -> str:
        try:
            with urllib.request.urlopen("https://api.ipify.org?format=json", timeout=5) as response:
                return json.loads(response.read().decode())["ip"]
        except:
            return "127.0.0.1"

    @staticmethod
    def track(ip: str = "") -> Dict:
        target = ip.strip() if ip else SpiffyTracker.get_local_ip()
        
        # Primary API: ipwho.is (Robust, handles reserved ranges with detailed messages)
        try:
            url = f"https://ipwho.is/{target}"
            req = urllib.request.Request(url, headers={'User-Agent': 'SpiffyTracer/13.0'})
            with urllib.request.urlopen(req, timeout=5) as response:
                data = json.loads(response.read().decode())
                if data.get("success"):
                    return {
                        "status": "success",
                        "query": data.get("ip"),
                        "city": data.get("city"),
                        "regionName": data.get("region"),
                        "country": data.get("country"),
                        "lat": data.get("latitude"),
                        "lon": data.get("longitude"),
                        "isp": data.get("connection", {}).get("isp"),
                        "type": data.get("type", "Standard")
                    }
                else:
                    return {"status": "fail", "message": data.get("message", "Unknown resolution error")}
        except:
            pass

        # Secondary API: ipapi.co (HTTPS, very reliable fallback)
        try:
            url = f"https://ipapi.co/{target}/json/"
            req = urllib.request.Request(url, headers={'User-Agent': 'SpiffyTracer/13.0'})
            with urllib.request.urlopen(req, timeout=5) as response:
                data = json.loads(response.read().decode())
                if "error" not in data:
                    return {
                        "status": "success",
                        "query": data.get("ip"),
                        "city": data.get("city"),
                        "regionName": data.get("region"),
                        "country": data.get("country_name"),
                        "lat": data.get("latitude"),
                        "lon": data.get("longitude"),
                        "isp": data.get("org"),
                        "type": "Static/Hosting"
                    }
        except Exception as e:
            return {"status": "fail", "message": str(e)}

        return {"status": "fail", "message": "Signal lost. All geolocation nodes unreachable."}

class SpiffyTUI:
    def __init__(self, db_manager):
        self.db = db_manager
        self.tunnel = SpiffyTunnel()
        self.running = True
        self.current_user_id = None

    def clear(self):
        print(C_CLEAR, end="")

    def type_text(self, text, delay=0.01, color=C_GREEN):
        for char in text:
            sys.stdout.write(color + char + C_END)
            sys.stdout.flush(); time.sleep(delay)
        print()

    def draw_box(self, content: List[str], title: str = "", color=C_CYAN):
        if not content: return
        width = max(len(str(line)) for line in content) + 4
        if title and (len(title) + 4 > width): width = len(title) + 4
        
        print(color + "┏" + ("━" * (width - 2)) + "┓" + C_END)
        if title:
            print(color + "┃ " + C_BOLD + title.center(width - 4) + C_END + color + " ┃" + C_END)
            print(color + "┣" + ("━" * (width - 2)) + "┫" + C_END)
        
        for line in content:
            print(color + "┃ " + C_WHITE + str(line).ljust(width - 4) + C_END + color + " ┃" + C_END)
        print(color + "┗" + ("━" * (width - 2)) + "┛" + C_END)

    def boot_sequence(self):
        self.clear()
        logs = [
            "INITIALIZING SPIFFY SENTINEL KERNEL 13.0...",
            "LOADING ENCRYPTED SQLITE INFRASTRUCTURE...",
            "SYNCHRONIZING ASYNCIO NETWORK DRIVERS...",
            "SYSTEM READY. GHOST PROTOCOL MODULES LOADED."
        ]
        for log in logs:
            self.type_text(f"[ OK ] {log}", delay=0.005, color=C_D_GREEN)
            time.sleep(0.04)

    def draw_banner(self):
        banner = r"""
   ███████╗██████╗ ██╗███████╗███████╗██╗   ██╗
   ██╔════╝██╔══██╗██║██╔════╝██╔════╝╚██╗ ██╔╝
   ███████╗██████╔╝██║█████╗  █████╗   ╚████╔╝ 
   ╚════██║██╔═══╝ ██║██╔══╝  ██╔══╝    ╚██╔╝  
   ███████║██║     ██║██║     ██║        ██║   
   ╚══════╝╚═╝     ╚═╝╚═╝     ╚═╝        ╚═╝   
        """
        print(C_GREEN + C_BOLD + banner + C_END)
        
        status = "GRID: ONLINE"
        if self.tunnel.is_active():
            status = f"GHOST: {self.tunnel.virtual_ip} [{self.tunnel.get_remaining_time()}]"
        
        print(C_GRAY + f" SENTINEL KERNEL V13.0 | {datetime.now().strftime('%H:%M:%S')} | {status}".center(55) + C_END)
        print()

    def show_spinner(self, duration=1.0, text="PROCESSING"):
        chars = "█▓▒░"
        end_time = time.time() + duration
        while time.time() < end_time:
            char = random.choice(chars)
            sys.stdout.write(f"\r{C_GREEN}[{char}] {text}...{C_END}")
            sys.stdout.flush()
            time.sleep(0.1)
        sys.stdout.write("\r" + " " * (len(text) + 25) + "\r")

    def glitch_decrypt(self, target_text, duration=0.8):
        chars = string.ascii_letters + string.digits + "!@#$%^&*"
        display = list(" " * len(target_text))
        end_time = time.time() + duration
        while time.time() < end_time:
            for i in range(len(target_text)):
                if random.random() > 0.88: display[i] = target_text[i]
                else: display[i] = random.choice(chars)
            sys.stdout.write(f"\r{C_YELLOW}{''.join(display)}{C_END}")
            sys.stdout.flush(); time.sleep(0.03)
        sys.stdout.write(f"\r{C_GREEN}{C_BOLD}{target_text}{C_END}\n")

    def main_menu(self):
        self.boot_sequence()
        while self.running:
            self.clear(); self.draw_banner()
            menu_items = [
                "[1] ENROLL NEW IDENTITY",
                "[2] ACCESS SECURE VAULT",
                "[3] GEOLOCATION TRACKER",
                "[4] WEB VULNERABILITY AUDIT",
                "[5] ASYNC PORT SCANNER",
                "[6] GHOST TUNNEL (IP CHANGER - 20m)",
                "[7] GENERATE ENTROPY KEY",
                "[8] DISCONNECT SESSION"
            ]
            self.draw_box(menu_items, "CORE OPERATING MODULES")
            choice = input(f"\n{C_CYAN}SENTINEL@ROOT:# {C_END}").strip()

            if choice == "1": self.handle_registration()
            elif choice == "2": self.handle_login()
            elif choice == "3": self.handle_tracking()
            elif choice == "4": self.handle_audit()
            elif choice == "5": asyncio.run(self.handle_port_scan())
            elif choice == "6": self.handle_ip_proxy()
            elif choice == "7": self.handle_pw_gen()
            elif choice == "8": self.type_text("PURGING KERNEL MEMORY...", color=C_RED); self.running = False

    def handle_ip_proxy(self):
        self.clear(); self.draw_banner()
        if self.tunnel.is_active():
            self.draw_box([f"STATUS: TUNNEL ACTIVE", f"VIRTUAL IP: {self.tunnel.virtual_ip}", f"REMAINING: {self.tunnel.get_remaining_time()}"], "GHOST PROTOCOL", C_GREEN)
            input("\nPRESS ENTER TO CONTINUE...")
        else:
            self.type_text("CONNECTING TO VIRTUAL RELAY NETWORK...", color=C_YELLOW)
            vip = self.tunnel.establish(20)
            time.sleep(1.5)
            self.draw_box([f"ESTABLISHED VIRTUAL INTERFACE", f"ASSIGNED IP: {vip}", "EXPIRY: 20 MINUTES"], "GHOST TUNNEL SUCCESS", C_CYAN)
            input("\nPRESS ENTER...")

    def handle_registration(self):
        self.clear(); self.draw_banner()
        self.draw_box(["IDENTITY REGISTRATION PROTOCOL"], "SECURE ENROLLMENT")
        u = input(f"{C_YELLOW}UID: {C_END}"); p = getpass.getpass(f"{C_YELLOW}KEY: {C_END}")
        self.show_spinner(0.5, "HASHING SIGNAL")
        s, m = self.db.register_user(u, p); self.type_text(m, color=C_GREEN if s else C_RED); time.sleep(1.5)

    def handle_login(self):
        self.clear(); self.draw_banner()
        self.draw_box(["AUTHENTICATION REQUIRED"], "IDENTITY CHALLENGE")
        u = input(f"{C_YELLOW}UID: {C_END}"); p = getpass.getpass(f"{C_YELLOW}KEY: {C_END}")
        self.show_spinner(0.8, "IDENTITY CHALLENGE")
        uid, m = self.db.login(u, p)
        if uid: self.current_user_id = uid; self.vault_loop(u)
        else: self.type_text(m, color=C_RED); time.sleep(1.5)

    def vault_loop(self, username):
        while True:
            self.clear(); self.draw_banner()
            self.draw_box([f"ACTIVE SESSION: {username.upper()}", "1. QUERY | 2. APPEND | 3. DISCONNECT"], "SECURE VAULT")
            choice = input(f"{C_GREEN}{username}@VAULT:$ {C_END}")
            if choice == "1":
                secrets = self.db.get_secrets(self.current_user_id)
                for s in secrets:
                    print(f"{C_CYAN}ID-{s['id']}: {s['title']} ({s['website']}){C_END}")
                    sys.stdout.write("  KEY: "); self.glitch_decrypt(s['secret_value'])
                input("\nPRESS ENTER...")
            elif choice == "2":
                self.db.add_secret(self.current_user_id, input("TITLE: "), input("DOMAIN: "), input("UID: "), input("KEY: "))
            elif choice == "3": break

    def handle_tracking(self):
        self.clear(); self.draw_banner()
        self.draw_box(["LEAVE BLANK FOR LOCAL DEVICE TRACE"], "GEOLOCATION ENGINE")
        ip = input(f"{C_YELLOW}TARGET IP: {C_END}").strip()
        
        if not ip and self.tunnel.is_active():
            ip = self.tunnel.virtual_ip
            self.type_text(f"ROUTING TRACE THROUGH GHOST PROXY: {ip}", color=C_CYAN)

        self.show_spinner(1.5, "INTERCEPTING SIGNAL")
        res = SpiffyTracker.track(ip)
        if res.get("status") == "success":
            results = [
                f"IP: {res['query']}",
                f"LOC: {res['city']}, {res['regionName']}, {res['country']}",
                f"GPS: {res['lat']}, {res['lon']}",
                f"ISP: {res['isp']}",
                f"NET: {res['type']}"
            ]
            self.draw_box(results, "LOCATION DATA ACQUIRED", C_GREEN)
            with open(REPORT_FILE, "a") as f: f.write(json.dumps(res) + "\n")
        else:
            self.type_text(f"TRACE FAILED: {res.get('message')}", color=C_RED)
            if "reserved" in res.get("message", "").lower():
                self.type_text("HINT: The target is an Internal/Bogon Signal. Geolocation is physically impossible.", color=C_YELLOW)
        input("\nPRESS ENTER...")

    def handle_audit(self):
        self.clear(); self.draw_banner()
        target = input(f"{C_YELLOW}TARGET URL: {C_END}").strip()
        self.show_spinner(1.2, "AUDITING GRID")
        res = SpiffyAuditor.audit_url(target)
        if "error" not in res:
            header_results = [f"{h}: {v}" for h, v in res["headers"].items()]
            self.draw_box([f"STATUS: {res['status']}", f"SERVER: {res['server']}"] + header_results, "AUDIT REPORT", C_YELLOW)
            if res["risks"]:
                self.draw_box(res["risks"], "DETECTED RISKS", C_RED)
        else:
            self.type_text(f"AUDIT ERROR: {res['error']}", color=C_RED)
        input("\nPRESS ENTER...")

    async def handle_port_scan(self):
        self.clear(); self.draw_banner()
        target = input(f"{C_YELLOW}TARGET HOST: {C_END}").strip()
        if "://" in target: target = urllib.parse.urlparse(target).netloc
        self.show_spinner(1.0, f"PROBING {target}")
        ports = [21, 22, 23, 25, 53, 80, 443, 3306, 5432, 8080]
        tasks = [SpiffyAuditor.probe_port(target, p) for p in ports]
        results = await asyncio.gather(*tasks)
        open_ports = [str(p) for p in results if p]
        if open_ports:
            self.draw_box([f"PORT {p}: OPEN" for p in open_ports], "NETWORK SCAN RESULTS", C_GREEN)
        else:
            self.type_text("NO COMMON PORTS OPEN.", color=C_YELLOW)
        input("\nPRESS ENTER...")

    def handle_pw_gen(self):
        pw = ''.join(random.choice(string.ascii_letters + string.digits + "!@#$") for _ in range(24))
        self.type_text("GENERATING ENTROPY KEY...", color=C_YELLOW); self.glitch_decrypt(pw); input("\nDONE.")

def main():
    db = DatabaseManager(); tui = SpiffyTUI(db)
    try: tui.main_menu()
    except KeyboardInterrupt: print(f"\n{C_RED}TERMINATED.{C_END}")

if __name__ == "__main__":
    main()
