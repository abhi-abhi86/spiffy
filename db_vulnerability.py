#⚠️ DO NOT RUN THIS UNDER ANY CIRCUMSTANCES!

#I am not responsible for any damage or misuse.

#This is for educational purposes only.



import sqlite3
import logging
import hashlib
import hmac
import os
import sys
import time
import re
import getpass
import random
import string
import urllib.request
import urllib.parse
import urllib.error
import ssl
import socket
import threading
from queue import Queue
from contextlib import contextmanager
from datetime import datetime, timedelta
from typing import Optional, Tuple, List, Dict

# --- CONFIGURATION ---
DB_FILE = "spiffy_vault.db"
LOG_FILE = "spiffy_audit.log"
REPORT_FILE = "spiffy_report.txt"
MAX_LOGIN_ATTEMPTS = 5
LOCKOUT_DURATION_MINUTES = 15

# --- ANSI COLORS (ULTIMATE HACKER THEME) ---
C_GREEN = "\033[38;5;46m"    
C_D_GREEN = "\033[38;5;22m"  
C_CYAN = "\033[38;5;51m"
C_YELLOW = "\033[38;5;226m"
C_RED = "\033[38;5;196m"
C_MAGENTA = "\033[38;5;201m"
C_WHITE = "\033[38;5;231m"
C_BOLD = "\033[1m"
C_END = "\033[0m"
C_CLEAR = "\033[H\033[J"

# Global SSL Context for Auditing
ssl_context = ssl.create_default_context()
ssl_context.check_hostname = False
ssl_context.verify_mode = ssl.CERT_NONE

# Configure persistent logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s [%(levelname)s] %(name)s: %(message)s',
    handlers=[logging.FileHandler(LOG_FILE)]
)
logger = logging.getLogger("SpiffyKernel")

class DatabaseManager:
    """Handles the persistence layer with industry-standard encryption patterns."""
    def __init__(self, db_path: str = DB_FILE):
        self.db_path = db_path
        self._initialize_infrastructure()

    @contextmanager
    def get_connection(self):
        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row
        try:
            yield conn
        finally:
            conn.close()

    def _initialize_infrastructure(self):
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS users (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    username TEXT UNIQUE NOT NULL,
                    password_hash BLOB NOT NULL,
                    salt BLOB NOT NULL,
                    failed_attempts INTEGER DEFAULT 0,
                    lockout_until TIMESTAMP
                )
            ''')
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS secrets (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER NOT NULL,
                    title TEXT NOT NULL,
                    website TEXT,
                    username_ref TEXT,
                    secret_value TEXT NOT NULL,
                    FOREIGN KEY (user_id) REFERENCES users (id)
                )
            ''')
            cursor.execute('CREATE INDEX IF NOT EXISTS idx_user_id ON secrets(user_id)')
            conn.commit()

    def _hash_password(self, password: str, salt: bytes = None) -> Tuple[bytes, bytes]:
        if salt is None:
            salt = os.urandom(16)
        pw_hash = hashlib.scrypt(password.encode(), salt=salt, n=16384, r=8, p=1)
        return pw_hash, salt

    def register_user(self, username: str, password: str) -> Tuple[bool, str]:
        pw_hash, salt = self._hash_password(password)
        with self.get_connection() as conn:
            try:
                conn.execute(
                    "INSERT INTO users (username, password_hash, salt) VALUES (?, ?, ?)",
                    (username, pw_hash, salt)
                )
                conn.commit()
                return True, "SYSTEM: Identity verified. Admin access granted."
            except sqlite3.IntegrityError:
                return False, "ERROR: Identity collision. Username occupied."

    def login(self, username: str, password: str) -> Tuple[Optional[int], str]:
        now = datetime.now()
        with self.get_connection() as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM users WHERE username = ?", (username,))
            user = cursor.fetchone()
            if not user: return None, "FATAL: Access Denied. Identity unknown."

            if user['lockout_until']:
                lockout_time = datetime.fromisoformat(user['lockout_until'])
                if now < lockout_time:
                    wait_time = (lockout_time - now).seconds // 60 + 1
                    return None, f"LOCKED: Security override active for {wait_time}m."

            provided_hash, _ = self._hash_password(password, user['salt'])
            if hmac.compare_digest(user['password_hash'], provided_hash):
                conn.execute("UPDATE users SET failed_attempts = 0, lockout_until = NULL WHERE username = ?", (username,))
                conn.commit()
                return user['id'], "SUCCESS"
            else:
                new_fails = user['failed_attempts'] + 1
                lockout_ts = (now + timedelta(minutes=LOCKOUT_DURATION_MINUTES)).isoformat() if new_fails >= MAX_LOGIN_ATTEMPTS else None
                conn.execute("UPDATE users SET failed_attempts = ?, lockout_until = ? WHERE username = ?", (new_fails, lockout_ts, username))
                conn.commit()
                return None, f"FAIL: Signal mismatch ({new_fails}/{MAX_LOGIN_ATTEMPTS})."

    def add_secret(self, user_id: int, title: str, website: str, user_ref: str, value: str):
        with self.get_connection() as conn:
            conn.execute(
                "INSERT INTO secrets (user_id, title, website, username_ref, secret_value) VALUES (?, ?, ?, ?, ?)",
                (user_id, title, website, user_ref, value)
            )
            conn.commit()

    def get_secrets(self, user_id: int, search: str = "") -> List[sqlite3.Row]:
        with self.get_connection() as conn:
            cursor = conn.cursor()
            if search:
                cursor.execute(
                    "SELECT * FROM secrets WHERE user_id = ? AND (title LIKE ? OR website LIKE ?)",
                    (user_id, f"%{search}%", f"%{search}%")
                )
            else:
                cursor.execute("SELECT * FROM secrets WHERE user_id = ?", (user_id,))
            return cursor.fetchall()

class SpiffyAuditor:
    """Ultimate Discovery & Audit Engine."""
    
    SECURITY_HEADERS = ["Content-Security-Policy", "Strict-Transport-Security", "X-Frame-Options", "X-Content-Type-Options"]
    SENSITIVE_PATHS = ["/admin", "/login", "/.env", "/.git", "/backup", "/robots.txt", "/wp-admin", "/phpmyadmin"]
    COMMON_PORTS = [21, 22, 23, 25, 53, 80, 443, 3306, 5432, 8080]
    SUBDOMAIN_PREFIXES = ["www", "mail", "ftp", "admin", "dev", "test", "api", "vpn", "portal"]

    @staticmethod
    def deep_audit(url: str) -> Dict:
        """Performs a comprehensive web infrastructure analysis."""
        if not url.startswith(('http://', 'https://')): url = 'http://' + url
        report = {"url": url, "status": "Offline", "leaks": [], "vulnerabilities": [], "shadow_paths": []}
        
        try:
            req = urllib.request.Request(url, headers={'User-Agent': 'SpiffyKernel/9.0'})
            with urllib.request.urlopen(req, timeout=10, context=ssl_context) as response:
                report["status"] = response.getcode()
                headers = response.info()
                content = response.read().decode('utf-8', errors='ignore').lower()
                
                for h in SpiffyAuditor.SECURITY_HEADERS:
                    if h not in headers: report["vulnerabilities"].append(f"Missing Security Header: {h}")
                
                for leak in ["Server", "X-Powered-By"]:
                    if leak in headers: report["leaks"].append(f"Header Leak: {headers[leak]}")

                if 'type="file"' in content:
                    report["vulnerabilities"].append("Potential Arbitrary File Upload Entry Point")
                
                parsed = urllib.parse.urlparse(url)
                if 'id=' in parsed.query or 'query=' in parsed.query:
                    report["vulnerabilities"].append("Dynamic Parameter detected (SQLi/XSS Risk)")

        except Exception as e: report["error"] = str(e)
        return report

    @staticmethod
    def threaded_port_scan(target: str, callback=None) -> List[int]:
        """High-speed multithreaded port scanner."""
        if "://" in target: target = urllib.parse.urlparse(target).netloc.split(':')[0]
        open_ports = []
        
        def scan(p):
            try:
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(0.5)
                    if s.connect_ex((target, p)) == 0:
                        open_ports.append(p)
            except: pass

        threads = []
        for p in SpiffyAuditor.COMMON_PORTS:
            if callback: callback(p)
            t = threading.Thread(target=scan, args=(p,))
            threads.append(t)
            t.start()
        
        for t in threads: t.join()
        return sorted(open_ports)

    @staticmethod
    def subdomain_discovery(domain: str, callback=None) -> List[str]:
        """Attempts to resolve common subdomains for a given target."""
        if "://" in domain: domain = urllib.parse.urlparse(domain).netloc.split(':')[0]
        found = []
        for prefix in SpiffyAuditor.SUBDOMAIN_PREFIXES:
            if callback: callback(prefix)
            sub = f"{prefix}.{domain}"
            try:
                socket.gethostbyname(sub)
                found.append(sub)
            except: pass
        return found

class SpiffyTUI:
    """The Ultimate Hacker-Style Terminal Interface."""
    def __init__(self, db_manager):
        self.db = db_manager
        self.running = True
        self.current_user_id = None

    def clear(self):
        print(C_CLEAR, end="")

    def type_text(self, text, delay=0.01, color=C_GREEN):
        for char in text:
            sys.stdout.write(color + char + C_END)
            sys.stdout.flush()
            time.sleep(delay)
        print()

    def boot_sequence(self):
        self.clear()
        logs = [
            "KERNEL 9.0 INITIALIZING...", "MOUNTING ENCRYPTED STORAGE...",
            "ESTABLISHING SOCKET BRIDGES...", "LOADING AUDIT LIBRARIES...",
            "SPIFFY OS v9.0 READY (AUTHORIZED USE ONLY)"
        ]
        for log in logs:
            self.type_text(f"[ OK ] {log}", delay=0.005, color=C_D_GREEN)
            time.sleep(0.05)

    def draw_banner(self):
        banner = r"""
   ███████╗██████╗ ██╗███████╗███████╗██╗   ██╗
   ██╔════╝██╔══██╗██║██╔════╝██╔════╝╚██╗ ██╔╝
   ███████╗██████╔╝██║█████╗  █████╗   ╚████╔╝ 
   ╚════██║██╔═══╝ ██║██╔══╝  ██╔══╝    ╚██╔╝  
   ███████║██║     ██║██║     ██║        ██║   
   ╚══════╝╚═╝     ╚═╝╚═╝     ╚═╝        ╚═╝   
        """
        print(C_GREEN + C_BOLD + banner + C_END)
        print(C_D_GREEN + f" > SPIFFY_ULTIMATE_KERNEL_{datetime.now().year} < " + C_END)
        print()

    def glitch_decrypt(self, target_text, duration=1.0):
        chars = string.ascii_letters + string.digits + "!@#$%^&*"
        display = list(" " * len(target_text))
        end_time = time.time() + duration
        while time.time() < end_time:
            for i in range(len(target_text)):
                if random.random() > 0.85: display[i] = target_text[i]
                else: display[i] = random.choice(chars)
            sys.stdout.write(f"\r{C_YELLOW}{''.join(display)}{C_END}")
            sys.stdout.flush(); time.sleep(0.03)
        sys.stdout.write(f"\r{C_GREEN}{C_BOLD}{target_text}{C_END}\n")

    def main_menu(self):
        self.boot_sequence()
        while self.running:
            self.clear(); self.draw_banner()
            print(f"{C_GREEN}[1]{C_END} REGISTER ADMIN SIGNATURE")
            print(f"{C_GREEN}[2]{C_END} AUTHENTICATE & ACCESS KERNEL")
            print(f"{C_GREEN}[3]{C_END} FULL INFRASTRUCTURE AUDIT")
            print(f"{C_GREEN}[4]{C_END} MULTITHREADED PORT SCAN")
            print(f"{C_GREEN}[5]{C_END} SUBDOMAIN DISCOVERY {C_MAGENTA}[NEW]{C_END}")
            print(f"{C_GREEN}[6]{C_END} GENERATE ENTROPY KEY")
            print(f"{C_GREEN}[7]{C_END} SYSTEM DISCONNECT")
            print("-" * 55)
            choice = input(f"{C_GREEN}SPIFFY@ROOT:# {C_END}")

            if choice == "1": self.handle_registration()
            elif choice == "2": self.handle_login()
            elif choice == "3": self.handle_full_audit()
            elif choice == "4": self.handle_port_scan()
            elif choice == "5": self.handle_subdomain_discovery()
            elif choice == "6": self.handle_pw_gen()
            elif choice == "7": self.type_text("PURGING BUFFER. BYE.", color=C_RED); self.running = False

    def handle_full_audit(self):
        self.clear(); self.draw_banner()
        target = input(f"{C_YELLOW}TARGET URL: {C_END}")
        if not target: return
        self.type_text("PROBING TARGET...", color=C_CYAN)
        report = SpiffyAuditor.deep_audit(target)
        
        output = f"\n--- SPIFFY AUDIT REPORT: {target} ---\n"
        output += f"Status: {report['status']}\n"
        if report['vulnerabilities']:
            output += "VULNERABILITIES DETECTED:\n"
            for v in report['vulnerabilities']: output += f"  [!] {v}\n"
        
        print(C_YELLOW + output + C_END)
        with open(REPORT_FILE, "a") as f: f.write(output + "\n" + "-"*30 + "\n")
        print(f"{C_GREEN}Report saved to {REPORT_FILE}{C_END}")
        input("\nPress Enter...")

    def handle_port_scan(self):
        self.clear(); self.draw_banner()
        target = input(f"{C_YELLOW}TARGET HOST: {C_END}")
        if not target: return
        self.type_text("INITIATING MULTITHREADED SCAN...", color=C_CYAN)
        open_ports = SpiffyAuditor.threaded_port_scan(target)
        print(f"\n{C_BOLD}OPEN PORTS:{C_END}")
        for p in open_ports: print(f"  - {C_GREEN}Port {p} OPEN{C_END}")
        input("\nPress Enter...")

    def handle_subdomain_discovery(self):
        self.clear(); self.draw_banner()
        domain = input(f"{C_YELLOW}DOMAIN (e.g. google.com): {C_END}")
        if not domain: return
        self.type_text("SEARCHING FOR SUBDOMAINS...", color=C_CYAN)
        found = SpiffyAuditor.subdomain_discovery(domain)
        print(f"\n{C_BOLD}RESOLVED SUBDOMAINS:{C_END}")
        for s in found: print(f"  - {C_CYAN}{s}{C_END}")
        input("\nPress Enter...")

    def handle_registration(self):
        self.clear(); self.draw_banner(); u = input("UID: "); p = getpass.getpass("KEY: "); c = getpass.getpass("CONFIRM: ")
        if p != c: self.type_text("MISMATCH", color=C_RED); time.sleep(1); return
        s, m = self.db.register_user(u, p); self.type_text(m, color=C_GREEN if s else C_RED); time.sleep(1)

    def handle_login(self):
        self.clear(); self.draw_banner(); u = input("UID: "); p = getpass.getpass("KEY: ")
        uid, m = self.db.login(u, p)
        if uid: self.current_user_id = uid; self.vault_loop(u)
        else: self.type_text(m, color=C_RED); time.sleep(1)

    def vault_loop(self, username):
        while True:
            self.clear(); self.draw_banner(); self.type_text(f"VAULT_ACTIVE: {username.upper()}", color=C_GREEN)
            print("1. QUERY SECRETS | 2. APPEND SECRET | 3. DISCONNECT")
            choice = input(f"{C_GREEN}{username}@VAULT:$ {C_END}")
            if choice == "1":
                search = input("FILTER: "); secrets = self.db.get_secrets(self.current_user_id, search)
                for s in secrets:
                    self.type_text(f"[{s['id']}] {s['title']} ({s['website']})", color=C_CYAN)
                    sys.stdout.write("  KEY: "); self.glitch_decrypt(s['secret_value'])
                input("\nDone...")
            elif choice == "2":
                t = input("TITLE: "); w = input("WEB: "); u = input("UID: "); p = input("KEY: ")
                self.db.add_secret(self.current_user_id, t, w, u, p)
            elif choice == "3": break

    def handle_pw_gen(self):
        pw = ''.join(random.choice(string.ascii_letters + string.digits + "!@#$") for _ in range(24))
        self.type_text("GENERATING HIGH-ENTROPY KEY...", color=C_YELLOW); self.glitch_decrypt(pw); input("\nDONE.")

def main():
    db = DatabaseManager(); tui = SpiffyTUI(db)
    try: tui.main_menu()
    except KeyboardInterrupt: print(f"\n{C_RED}HARD SHUTDOWN.{C_END}")

if __name__ == "__main__":
    main()
